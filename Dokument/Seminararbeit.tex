\documentclass[conference]{IEEEtran}
\IEEEoverridecommandlockouts
% The preceding line is only needed to identify funding in the first footnote. If that is unneeded, please comment it out.
\usepackage{cite}
\usepackage{amsmath,amssymb,amsfonts}
\usepackage{algorithmic}
\usepackage{graphicx}
\usepackage{textcomp}
\usepackage{xcolor}
\usepackage[ngerman]{babel}
\usepackage[utf8]{inputenc}
\def\BibTeX{{\rm B\kern-.05em{\sc i\kern-.025em b}\kern-.08em
    T\kern-.1667em\lower.7ex\hbox{E}\kern-.125emX}}
 
    
\begin{document}


\title{Implementierung Objektorientierter-Konstrukte in der Java Virtual Machine\\}

\author{\IEEEauthorblockN{Braun Georg}
\IEEEauthorblockA{\textit{Fachhochschule Aachen} \\
Aachen, Deutschland \\
Georg.Braun@alumni.fh-aachen.de}
}

\maketitle

\begin{abstract}

\end{abstract}



\section{Einleitung}
Java ist einer der beliebtesten objektorientierten Programmiersprachen und ist schon seit einigen Jahren eine etabliert. Neben Java gibt es noch diverse andere Programmiersprachen, wie zum Beispiel Kotlin oder Clojure die alle eine elementare Gemeinsamkeit haben. Alle diese Sprachen werden nicht speziell für eine Rechnerarchitektur, sondern in einen Bytecode kompiliert. Dieser Bytecode kann von Java Virtual Machines verarbeitet werden. Somit ist eine Ausführung des Code unabhängig von der zugrunde liegenden Rechnerarchitektur möglich (vorausgesetzt die Java Virtual Machine kann auf dieser betrieben werden). Im Fokus dieses Dokuments steht die Bytecode Repräsentation von objektorientierten Konstrukten. Dazu wird zunächst auf die Struktur der Java Klassen-Dateien eingegangen um darauf die zum Verständnis notwendigen Grundlagen der Struktur der Java Virtual Machine aufzugreifen. Danach findet eine Erklärung statt wie auf Bytecode-Ebene Methoden aufgerufen werden. Neben der Umsetzung von Konstruktor-Aufrufen werden auch die Zugriffe auf Objektfelder und Klassen- bzw. Static-Felder erläutert. Zuletzt wird noch auf die Bytecode-Implementation von Typ-Überprüfungen eingegangen.  

\section{Aufbau der class Datei}
Der Programmcode der Hochsprachen wird beim Kompilieren in Bytecode umgewandelt und für jede verwendete Klasse wird eine entsprechende Klassen-Datei (.class) angelegt. Diese Dateien haben eine klar definierte Struktur die in Tabelle \ref{tab1} aufgelistet ist und auf die im folgenden eingegangen wird. eingegangen wird.


\begin{table}[htbp]
\caption{Reihenfolge und Länge der class-Datei Inhalte}
\begin{center}
\begin{tabular}{|c|c|}
\hline
\textbf{Element} & \textbf{Länge} \\
\hline
Magic & 4 Bytes\\
\hline
Major, Minor Version & 4 Bytes\\
\hline
Constant Pool & variabel \\
\hline
Access Flags & 2 Bytes \\
\hline
This Klasse & 2 Bytes \\
\hline
Basisklasse (super) & 2 Bytes \\
\hline
Interfaces & variabel \\
\hline
Felder & variabel \\
\hline
Methoden & variabel \\
\hline
Attribute & variabel \\
\hline
\end{tabular}
\label{tab1}
\end{center}
\end{table}

%ToDo: Beschreibung der Inhalte der class-Datei. Besser noch konkrete Beispiele dafür mit in die Tabelle aufnehmen
Die Datei startet zunächst mit einem Magic welches vier Byte lang ist und die Datei als eine Java-Klassen-Datei identifiziert. Dieses Magic hat den fixen Wert 0xCAFEBABE. Darauf folgen die Major- und Minor-Versionsinformationen welche die verwendete Compilerversion identifizieren. Die nächsten Bytes beschreiben die Länge des folgenden Constant-Pools. Durch diese Angabe ist der Java Virtual Machine bekannt wie viele der folgenden Bytes zum Constant Pool gehören. Dieser enthält Konstanten die mit der Klasse, beziehungsweise dem Interface assoziiert werden. Der Constant-Pool ist als Array variabler Länge umgesetzt. Auf die Elemente kann später über einen Index-Mechanismus zugegriffen werden. Dabei enthält ein Element zunächst ein Byte welches den Typ spezifiziert. Auf Grundlage dieses Typs werden die darauf folgenden Bytes des Elements interpretiert. Nach dem Constant-Pool werden in zwei Bytes die Access-Flags angegeben. Dabei handelt es sich um Flags die beschreiben ob es sich um eine Klasse oder um ein Interface (\verb|ACC_INTERFACE| Flag) handelt. Zudem werden darüber die Zugriffsrechte bekannt gegeben. Beispielsweise wird für einen public Zugriff das Flag \verb|ACC_PUBLIC| verwendet. In den nächsten zwei Bytes steht die this-Information welche die in dieser Klassen-Datei behandelte Klasse oder Interface definiert. Dazu werden diese zwei Bytes als Index im Constant-Pool interpretiert. Dieser muss an dem gegeben Index ein Element des Typs \verb|CONSTANT_Class| enthalten. Dieser wiederum verweist auf ein String-Element welchen den Namen der Klasse beziehungsweise des Interfaces enthält. Die nächsten zwei Bytes geben die verwendete Elternklasse an. Auch hier werden diese zwei Bytes als Index im Constant-Pool interpretiert. Auch in diesem Element sollte der Typ \verb|CONSTANT_Class| stehen und auf die Elternklasse im String-Format verweisen. Nach dieser Angabe folgen die verwendeten Interfaces. Auch an dieser Stelle geben die ersten zwei Bytes die Anzahl der Interfaces an, sodass die Java Virtual Machine die folgenden Bytes richtig interpretieren kann. Der gleiche Mechanismus (Angabe der Anzahl in den ersten zwei Bytes und darauf folgend der jeweilige Inhalt) wird bei den folgenden Klassen-Datei Inhalten auch verwendet. Das Element Felder enthält eine Beschreibung alle Felder die in der Klasse oder dem Interface deklariert wurden. Geerbte Felder werden hier nicht repräsentiert. Ähnlich verhält es sich bei den folgenden Methoden-Definitionen. Diese enthalten (sofern nicht als abstrakt gekennzeichnet) neben der Deklaration auch die komplette Implementation. Dabei werden neben Instanz-Methoden auch Klassen- und Initialisierungsmethoden angegeben. Als letztes kann die Klassen-Datei noch verschiedene Attribute wie zum Beispiel die verwendete Quell-Datei enthalten. \cite{Venners.1996b} \cite{Lindholm.21.08.2018}

\section{Java Virtual Machine Grundlagen Stack und Heap}

% Quelle: JVM SE Specification!
Die Java Virtual Machine besteht aus verschiedenen Bereichen wobei ich im folgenden besonders den Java Virtual Machine Stack und den Heap hervorheben möchte.

Jeder Thread besitzt einen eigenen Java Virtual Machine Stack der zeitgleich mit der Threaderstellung entsteht. Dieser Stack enthält \verb|Frames|. Bei jedem Methodenaufruf wird ein neues Frame erstellt und auf dem Stack abgelegt. Ein Frame besteht aus einem Operanden-Stack, einem Array von lokalen Variablen und einer Referenz zum Runtime Constant-Pool. Der Operanden-Stack ist ein LIFO-Stack der durch Opcodes manipuliert werden kann. Das Array der lokalen Variablen hat zwei Funktionen. Zunächst enthält es bei einem Methodenaufruf die übergebenen Parameter. Die zweite Funktion ist das Speichern der Werte von lokalen Variablen. Handelt es sich bei einem Methodenaufruf um eine Instanz-Methode, so ist der erste Wert in dem Array (Index 0) eine Referenz auf das beim Aufruf verwendete Objekt (this-Referenz). Beim Runtime Constant Pool handelt es sich um eine Laufzeit-Repräsentation des in den Klassendateien definierten Constant Pools. Dieser Pool wird angelegt sobald eine Klasse oder ein Interface erstellt wird. 

Der Runtime Constant Pool ist wiederum ein Teil der Method Area welche sich im Heap Bereich befindet. Der Heap ist für alle Java Virtual Machine Threads zugänglich und dient als Laufzeitspeicher der von allen Klassen und Interfaces allokiert wird. Die Method Area verwaltet zum Beispiel folgende Informationen der Klassen/Interfaces: Runtime Constant-Pool, Feldinformationen, Methodencode und Konstruktoren. Der (von Objekten) allokierte Speicher im Heap wird dabei nie explizit freigegeben. Diese Aufgabe übernimmt der Garbage Collector. \cite{Lindholm.21.08.2018}



\section{Methodenaufrufe}
\subsection{Ablauf eines Methodenaufrufs}
Sobald eine Methode aufgerufen wird erzeugt die Java Virtual Machine ein neues Frame und legt dieses auf den Frame-Stack. Sofern es sich um eine Instanz-Methode handelt werden im Kontext der aufrufenden Methode und in dessen Frame die Objekt-Referenz und potenzielle Methodenargumente von dem Operanden-Stack genommen und in den Frame der aufgerufenen Methode übergeben (siehe Abbildung \ref{fig:aufrufMethode}). Dort sind die Werte im Array der lokalen Variablen zu finden, wobei die Objekt-Referenz an erster Stelle (Index 0) steht und darauf folgend die potenziellen Methoden-Argumente. 

\begin{figure}[htbp] 
  \centering
     \includegraphics[width=0.4\textwidth]{Grafiken/MethodenAufrufJVM.png}
  \caption{Aufruf einer Instanz-Methode}
  \label{fig:aufrufMethode}
\end{figure}

Falls es sich um den Aufruf einer Klassen-Methode handelt werden nur die Argumente vom Operanden-Stack genommen und das Array der lokalen Variablen in dem Frame der aufgerufenen Methode startet ab Index 0 mit den Methoden-Argumenten. Sobald die Argumente in dem Array vorhanden aktiviert die Java Virtual Machine das neu erzeugte Frame und setzt den Instruktionszeiger auf die erste Instruktion der neuen Methode. 

\subsection{Vergleich der Methodenaufrufe}
\subsubsection{Dynamic linking}
\subsubsection{Klassen-/Static-Methoden}
\subsubsection{Instanz-Methoden}

\subsection{Beispielprogramm}

\section{Konstruktor}

\section{Zugriff auf Felder}
\subsection{Zugriff auf Objekt-Felder}
\subsection{Zugriff auf Klassen-/Static-Felder}

\section{Typüberprüfung}

\bibliographystyle{ieeetr}
\bibliography{literatur} 

\end{document}
