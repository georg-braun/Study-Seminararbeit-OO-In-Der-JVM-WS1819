\documentclass[conference]{IEEEtran}
\IEEEoverridecommandlockouts
% The preceding line is only needed to identify funding in the first footnote. If that is unneeded, please comment it out.
\usepackage{cite}
\usepackage{amsmath,amssymb,amsfonts}
\usepackage{algorithmic}
\usepackage{graphicx}
\usepackage{textcomp}
\usepackage{xcolor}
\usepackage[ngerman]{babel}
\def\BibTeX{{\rm B\kern-.05em{\sc i\kern-.025em b}\kern-.08em
    T\kern-.1667em\lower.7ex\hbox{E}\kern-.125emX}}
    
    
\begin{document}


\title{Implementierung Objektorientierter-Konstrukte in der Java Virtual Machine\\}

\author{\IEEEauthorblockN{Braun Georg}
\IEEEauthorblockA{\textit{Fachhochschule Aachen} \\
Aachen, Deutschland \\
Georg.Braun@alumni.fh-aachen.de}
}

\maketitle

\begin{abstract}

\end{abstract}



\section{Einleitung}
Java ist einer der beliebtesten objektorientierten Programmiersprachen und ist schon seit einigen Jahren eine etabliert. Neben Java gibt es noch diverse andere Programmiersprachen, wie zum Beispiel Kotlin oder Clojure die alle eine elementare Gemeinsamkeit haben. Alle diese Sprachen werden nicht speziell für eine Rechnerarchitektur, sondern in einen Bytecode kompiliert. Dieser Bytecode kann von Java Virtual Machines verarbeitet werden. Somit ist eine Ausführung des Code unabhängig von der zugrunde liegenden Rechnerarchitektur möglich (vorausgesetzt die Java Virtual Machine kann auf dieser betrieben werden). Im Fokus dieses Dokuments steht die Bytecode Repräsentation von objektorientierten Konstrukten. Dazu wird zunächst auf die Struktur der Java class Dateien eingegangen um darauf die zum Verständnis notwendigen Grundlagen der Struktur der Java Virtual Machine aufzugreifen. Danach findet eine Erklärung statt wie auf Bytecode-Ebene Methoden aufgerufen werden. Neben der Umsetzung von Konstruktor-Aufrufen werden auch die Zugriffe auf Objektfelder und Klassen- bzw. Static-Felder erläutert. Zuletzt wird noch auf die Bytecode-Implementation von Typ-Überprüfungen eingegangen.  

\section{Aufbau der class Datei}
Der Programmcode der Hochsprachen wird beim Kompilieren in Bytecode umgewandelt und für jede verwendete Klasse wird eine entsprechende class Datei angelegt. Diese Dateien haben eine klar definierte Struktur die in Tabelle \ref{tab1} aufgelistet ist und auf die im folgenden eingegangen wird. eingegangen wird.


\begin{table}[htbp]
\caption{Reihenfolge und Länge der class-Datei Inhalte}
\begin{center}
\begin{tabular}{|c|c|}
\hline
\textbf{Element} & \textbf{Länge}\\
\hline
Magic & 4 Bytes\\
\hline
Major, Minor Version & 4 Bytes\\
\hline
Constant Pool & variabel \\
\hline
Access Flags & 2 Bytes \\
\hline
This Klasse & 2 Bytes \\
\hline
Basisklasse (super) & 2 Bytes \\
\hline
Interfaces & variabel \\
\hline
Felder & variabel \\
\hline
Methoden & variabel \\
\hline
Attribute & variabel \\
\hline
\end{tabular}
\label{tab1}
\end{center}
\end{table}

%ToDo: Beschreibung der Inhalte der class-Datei. Besser noch konkrete Beispiele dafür mit in die Tabelle aufnehmen

\section{Java Virtual Machine Grundlagen}

% Kurz auf die verschiedenen Bereiche eingehen: Heap, Stack, Non-Heap

% Beschreiben dass die JVM eine Stackbasierte Maschine ist
% Jeder Thread hat seinen eigenen Stack
% Woraus der Stack besteht (Frames -> Operandstack, array (Fokus bei Objektmethoden auch auf den ersten Parameter this legen), constant pool)

% Classloader beschreiben (siehe Zusammenfassung)

\section{Methodenaufrufe}
\subsection{Ablauf eines Methodenaufrufs}

\subsection{Vergleich der Methodenaufrufe}
\subsubsection{Dynamic linking}
\subsubsection{Klassen-/Static-Methoden}
\subsubsection{Instanz-Methoden}

\subsection{Beispielprogramm}

\section{Konstruktor}

\section{Zugriff auf Felder}
\subsection{Zugriff auf Objekt-Felder}
\subsection{Zugriff auf Klassen-/Static-Felder}

\section{Typüberprüfung}

\bibliography{literatur.bib} 

\end{document}
